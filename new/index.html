<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Yahoo YUI browser normalizer -->
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/3.18.1/build/cssnormalize/cssnormalize-min.css">

<!-- Fonts -->
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:300">
<link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

<!-- Steelbreeze styling -->
<link rel="stylesheet" type="text/css" href="steelbreeze.css">
    <title>state.js user guide: steelbreeze</title>
  </head>
  <body onload="showHideAlert('cookieAlert')">
    <header>
    <h1>steelbreeze open source</h1>
</header>
<main role="main">
<!--
    <div role="alert" class="alert" id="cookieAlert">
        <p>www.steelbreeze.net uses cookies; please see here for our policy. <i class="fa fa-close" onclick="closeAlert('cookieAlert', true)"></i></p>
    </div>
-->

    <section role="heading">
      <h1>state.js user guide</h1>
      <h2>An introduction to state.js for developers</h>
    </section>
    <section role="row">
      <p>This document is the user guide for state.js, it will introduce you the major uses of finite state machines, the core concepts in state.js and guide you through your first implementations.</p>
      <p>The detailed API reference can be found as a JSDoc in markdown format on GitHub.</p>
      <h1>What is state.js?</h1>
      <p>State.js is a JavaScript implementation of a finite state machine that broadly follows the semantics defined within the UML 2 superstructure specification; the differences to UML can be understood by reading the UML conformance section below.</p>
      <p>State machines can add value in many circumstances:</p>
      <ul>
      <li>Controllers in user interfaces</li>
      <li>Protocol handlers</li>
      <li>Business process management of major domain objects</li>
      <li>Nodes in complex event processing or neural networks</li>
      </ul>
      <p>A key characteristic of finite state machines is their ability to manage logic that reacts to non-deterministic events from multiple sources.</p>
      <p>State.js has been engineered not to depend on any other software and hence is very light-weight. It can be used with most other JavaScript frameworks.</p>
      <p>From version 5 onwards, state.js has been authored using Microsoft TypeScript; the state.js API is available for both JavaScript and TypeScript; all code can be found on GitHub. A TypeScript definitions file will be available at DefinitelyTyped shortly.</p>
      <p>State.js is also available as a Node Packaged Module and can be installed from the NPM Registry.</p>
      <h1>Core concepts in state.js</h1>
      <p>The following definitions are a subset of the glossary, found at the end of this document; they are useful to understand the more detailed descriptions that follow:</p>
      <table>
        <thead>
          <tr>
          <td>Term</td>
          <td>Description</td>
        </tr>
          </thead>
        <tbody>
        <tr>
          <td>Active state configuration</td>
          <td>The current, or last know, state of all regions (that have been entered) within state machine instance.</td>
        </tr>
        <tr>
          <td>Composite state</td>
          <td>A state within a state machine hierarchy that has child model structure. As such, it will have at least one child region.</td>
      </tr>
      <tr>
        <td>Event</td>
        <td>An event causes transitions from the active state configuration to be evaluated and if viable, traversed resulting in a state transition and potentially, an updated active state configuration.</td>
      </tr>
        <tr><td>Orthogonal state</td><td>A composite state that has two or more child regions. Each region within an orthogonal state may respond to events independently. Orthogonal states lead to concurrent active state configurations.</td></tr>
        <tr><td>Region</td><td>A region is a structural element within a state machine hierarchy; it is little more than a container of vertices.</td></tr>
        <tr><td>Pseudo state</td><td>A transitory vertex within a state machine model. Pseudo states have three main purposes: to control the initial active state with a region; as a means to create composite transitions; to terminate a state machine instance abrubtly.</td></tr>
        <tr><td>State</td><td>A state is the fundamental building block in a state machine; they represent significant points in the lifecycle of a state machine that require an event before they can transition to another state. States can have entry and exit behaviour.</td></tr>
        <tr><td>Transition</td><td>Transitions define the response the state machine will make to events. Transitions most commonly cause a transition from one vertex to another. Transitions can have traversal behaviour.</td></tr>
        <tr><td>State machine model</td><td>The state machine model defines the whole set of elements that makes up the state machine and the valid transitions allowed between vertices.</td></tr>
</tbody>
              </table>
      <p>These concepts are discussed in more detail below.</p>
      <h2>Models and instances</h2>
      <p>State.js splits state machines into two fundamental parts, a model that defines the static structure of the machine, and an instance that represents a particular active state configuration at runtime, this holds the current state of the state machine instance.</p>
      <h3>Context class</h3>
      <p>State.js provides a default context class implementation that you can use called Context. This can be used in any state machine model.</p>
      <h3>IActiveStateConfiguration interface</h3>
      <p>The context class above adheres to an interface, notionally called IActiveStateConfiguration. By implementing a class that implements this interface you can control the instance current state yourself, and add custom attributes to context classes.</p>
      <p>IActiveStateConfiguration requires the following property and methods:</p>
      <code>isTerminated: boolean;</code>
      <code>setCurrent(region: Region, state: State): void;</code>
      <code>getCurrent(region: Region): State;</code>
      <p>isTerminated is a getter setter property, indicating the state machine is in a terminated state or not; this will be set true if any transition was made to a terminate pseudo state.</p>
      <p>getCurrent and setCurrent record and replay the last known active child state for a given region.</p>
      <h2>State</h2>
      <p>States are the fundamental building block of a finite state machine, they represent a condition within the lifecycle of the machine. Typically, a state is an invariant condition, meaning that the finite state machine is at rest and will only resume processing when a message is received.</p>
      <h3>Entry &amp; exit behaviour</h3>
      <p>States can have pre-defined behaviour that will be executed on entry to the state, and when the state is exited. Entry and exit behaviour is the main programming construct for state machines and are set by calling the entry and exit methods on a state. The entry and exit methods may be called many times for any given state, adding more behaviour to the state.</p>
      <p>The behaviour that you can pass to the entry and exit methods can be of the following prototype:</p>
      <code>function (message, context)</code>
      <p>Where message can be of any type, but will be the message that caused the transition; context is an implementation if the IContext interface.</p>
      <p class="warning">Warning: be careful making assumptions in relation to the type of the message that caused a transition into the or out of the state.</p>
      <p>Being JavaScript, not all the parameters are required, so the following will work equally well:</p>
      <code>function (message)</code>
      <code>function ()</code>
      <p>The true value of state machines comes when entry and exit behaviour are implemented in pairs, as a hierarchical machine acts a little like a stack (this will be explained a little more below under composite states).</p>
      <h2>Final state</h2>
      <p>A final state is a special type of state that cannot have outbound transitions defined.</p>
      <p>Reaching a final state means that the enclosing region is deemed to be complete.</p>
      <h2>Pseudo state</h2>
      <p>Pseudo states are the helper objects within a state machine model; they are transitory vertices within a state machine model that serve a variety of purposes based on their kind. The kind of a pseudo state is passed as a parameter into its constructor.</p>
      <p>Pseudo states have no entry or exit behaviour; with the exception of terminate pseudo states, whenever they are entered, their outbound transitions are immediately evaluated.</p>
      <h3>Initial pseudo states</h3>
      <p>Initial pseudo states are the default stating states when entering their enclosing regions. They can have only a single transition out to another state or pseudo state.</p>
Shallow history pseudo states
As per initial pseudo states, shallow history pseudos state are the default stating state when entering their enclosing region for the first time. It can have only a single transition out to another state or pseudo state.
Subsequent entries to the region will start by entering the last known state for the region rather than the shallow history state.
Deep history pseudo states
As per initial and shallow history pseudo states, deep history pseudos state are the default stating state when entering their enclosing region for the first time. It can have only a single transition out to another state or pseudo state.
Subsequent entries to the region will start by entering the last known state for the region rather than the shallow history state. This history semantic will be cascaded to all regions nested below the enclosing region when entered regardless of the initial pseudo state kind.
Junction pseudo states
Junction pseudo states allow more complex transition logic to be implemented as they can have multiple outbound transitions. The guard conditions must be mutually exclusive as only a single outbound transition can be traversed.
Junction pseudo states may also have a single else transition defined. If none of the other outbound transitions guards evaluate true, the else transition will be followed.
Choice pseudo states
Choice pseudo states allow more complex transition logic to be implemented as they can have multiple outbound transitions. If more than one transition’s guard condition evaluates true, an arbitrary one is chosen.
Choice pseudo states may also have a single else transition defined. If none of the other outbound transitions guards evaluate true, the else transition will be followed.
Warning: Junction pseudo states should be used over Choice pseudo states unless the random behaviour is desirable.
Terminate pseudo states
Terminate pseudo states are a mechanism to halt the processing of a state machine. Once reached, the state machine instance will not respond to any more events.
If you use terminate pseudo states in your state machine model, you will need to test for termination against the state machine context object by evaluating it’s isTerminated property.
Composite state
A composite state is one which has child state machine model elements within it. The true power of finite state machines comes to bear in hierarchical machines; composite states are the mechanism to achieve this.
A state is converted automatically into a composite state when model elements are added to it. You can either add regions to it (by creating a new region instance whose parent is defined as the state), or adding a child state or pseudo state (these will implicitly inject a default region into the state machine model).
A composite state is only deemed to be complete when its child region is also complete.
When a composite state is entered, its child region is also entered (recall the initial, shallow history and deep history semantics above to understand entry to the region).
Orthogonal state
Orthogonal states are states with two or more child regions; and number of regions can be added to a state.
Orthogonal regions allow for any part of a state machine instance to have concurrent child state. This can be used for many different use cases. Each region can respond differently to messages passed to it and the regions do not depend on each other.
An orthogonal state is only deemed to be complete when all its child regions are also complete.
When an orthogonal state is entered, all its child regions are also entered (recall the initial, shallow history and deep history semantics above to understand entry to the region).
Simple states
A simple state is a term used to represent a state with no child model structure (regions).
Region
Regions are a structural construct within a finite state machine model; they are a container for states and pseudo states. They have no explicit behaviour.
Unless you require orthogonal regions, there is little need to use them, as the API will automatically inject them into the state machine model as required. Read more under orthogonal states below for an understanding of the need to use regions explicitly.
Transition
Transitions are used within a state machine model to define how state machine instances respond to different events. There are two major classes of events: state completion (see completion transitions below) and messages. Messages are some form of stimuli passed into a machine for evaluation.
Transitions are created either by calling the to method on a state or pseudo state, or by creating a new instance of the Transition class. The to method has a single optional parameter, being the target state of pseudo state; if omitted, the transition is an internal transition and does not cause a transition between states, but does have behaviour executed.
Transition guards
Newly creates transitions are completion transitions triggered solely due to successful entry to the source state or pseudo state; they are converted into message triggered transitions by defining a guard condition with the when method. Note that message triggered transitions can still be evaluated on successful entry to a state if the state is complete.
The when method accepts a function of the following prototype whose return is tested (any value other than undefined, null, or false will be treated as true and therefore passes the guard):
function (message, context)
Where message can be of any type, but will be the message that may cause the transition; context is an implementation if the IContext interface.
Being JavaScript, not all the parameters are required, so the following will work equally well:
function (message)
function ()
Guards are used to select the appropriate transition to follow where there are multiple defined.
Transition behaviour
Like the entry and exit behaviour defined for states, so transition may have behaviour associated with them. Transition behaviour is added to the transition by calling the effect method of the transition. A transitions behaviour is called after exiting the source state and before entering the target state.
The behaviour that you can pass to the effect method can be of the following prototype:
function (message, context)
Where message can be of any type, but will be the message that caused the transition; context is an implementation if the IContext interface.
Being JavaScript, not all the parameters are required, so the following will work equally well:
function (message)
function ()
You can call the effect method multiple times for any given transition, adding more behaviour to the transition with each call.
Internal transitions
An internal transition is one that does not cause a state change as it has no target state. When selected in response to an event, only its behaviour is performed.
Local transitions
A local transition is one whose source and target both are children of the same enclosing region. Once selected for traversal, the following processing will occur:
The source state or pseudo state will be exited and any specified exit behaviour performed.
Any specified transition behaviour will be performed.
The target state or pseudo state will be entered and any specified entry behaviour performed.
If the target is a state (not pseudo state), the enclosing regions current state will be update in the state machine instance context .
The target state’s completeness is tested and if true, completion transitions will be evaluated and if found, traversed.
When a successful state entry triggers a completion transition, the following transition can be either a local or external transition. Entry to all pseudo states will trigger a completion transition.
External transitions
An external transition is one whose source and target states or pseudo states are children of different enclosing regions. As such, exiting a state will also cause its parent ancestry to up to, but not including, the common ancestor of the source and target. Likewise, entering the target will be performed from the region below the common ancestor through the target ancestor to the target. The common ancestor between source and target must be a region.
The sequence of calls performed is the same as for local transitions but the exit and entry calls cascade through their ancestries to the states below the common ancestor. All the current states of all the impacted regions are updated as appropriate during the transition.
Composite transitions
Composite transition is a term to represent multiple transitions linked with pseudo states as intermediaries. Regions current state is not updated until the composite transition is complete and has ended in a state.
Completion transitions
Completion transitions are followed after entry to a state or a pseudo state and if the state or pseudo state is deemed to be complete. Pseudo states are always deemed to be complete, as are simple states; composite and orthogonal states are deemed complete only if all their child regions are complete (regions need their current state to be a final states to be deemed complete).
All newly created transitions are deemed to be completion transitions, and any message triggered transition can also be evaluated upon entry completion. This can be changed by calling the when method to define the guard condition that must be satisfied to trigger transition traversal.
Else transitions
Transitions can be converted to else transitions for use with choice and junction pseudo state by calling the else method on the transition.
State machines
A state machine is a special type of state used as the root element within a state machine model. State machines are the main class used at runtime after the state machine model has been built.
Initialisation
A single state machine model can be used to control many state machine instance by using different context objects. Each context object must be initialised before use with a call to the initialise method on the state machine. Initialising a context object will cause it to enter the initial pseudo state of each region owned by the root state machine. Once all these initialisation transitions have completed, the state machine instance will be ready to receive events.
Both the model and the context object need to be initialised for state.js to work correctly; under normal circumstances, calling the initialise method on the state machine will not only initialise the context object, but also check the model and initialises it if required (if the model has been extended dynamically). This behaviour can be controlled explicitly if required; see the detailed API reference for the initialise, evaluate and bootstrap methods.
Message evaluation
After model and instance initialisation, you can pass messages to a state machine model / instance combination for evaluation using the following method call:
model.evaluate(message, context)
Where model is an instance of the state machine class, message is any object, and context is the state machine instance. The evaluate method returns a boolean value which is true if the message caused a state transition.
Messages can be any type of external stimuli; typically any or all of the following:
User input
Messages from within the system
Messages from other systems
Time
Transition selection
When a message is passed to the machine for evaluation, it is passed to the most nested part of the state machine instance’s current state for evaluation (note that when a model has orthogonal states, this can actually be multiple current nested states). The current states outbound transitions guards are evaluated and if one is found, that transition is traversed. If not suitable transition was found and traversed, the parent composite state is tested in a similar way; this behaviour walks up the hierarchy from the leaf current state to the root looking for transitions to traverse. Finding a transition on any branch of the current state will cease evaluation from that point to the root state machine.
Transition traversal
Once selected, the transition will be traversed in accordance with the description of transitions above.
Using state.js in your project
This part of the document describes the various ways in which you can use state.js in your projects.
Simple JavaScript in a web page
Firstly, download state-5.0.0.min.js from from GitHub.
Within the page, insert the following script declaration:
Subsequent JavaScript code will have the fsm namespace available to you in which you will find the state.js classes.
Using the common.js or require.js module systems
State.js works natively with the common.js allowing dynamic loading and your own custom namespace.
To use state.js within common.js, download as before but then within your script, load as follows:
var statejs = require(“state-1.0.0.min”);
Replacing statejs above with the variable of you choice allows you to control the namespaces used within your script rather than relying on the fsm namespace which is the default for state.js.
Note: to work with require.js, you can run the command tsc -m AMD state.ts to compile the TypeScript into JavaScript with the require.js module conventions. This will require the TypeScript compiler to be installed. At the time of writing, this has not been tested.
TypeScript
As per simple JavaScript , download state-5.0.0.min.js from from GitHub.
Within your TypeScript source file, add the following declaration:
Your TypeScript code will now have the state.js fsm namespace available. The TypeScript definitions file will also available at DefinitelyTyped shortly.
In a node.js project
Firstly, install state.js with the following command:
npm install state.js
You can then use state.js in the common.js style used within node.
Building your first state machine
State machines build in either JavaScript or TypeScript will look very similar; the major noticeable difference in the resultant code will be in the typing of the behaviour callbacks. Therefore, this guide will walk you through building a state machine in JavaScript, then for the final solution only, show the equivalent TypeScript code.
The example used is based on a controller for a cassette player; the player has a primitive internal API consisting of the engageHead, disengageHead, startMotor and stopMotor calls; the player itself needs to respond to users pressing the play, pause, stop and off buttons.

JavaScript
We start every state machine by creating an instance of the state machine class:
var player = new fsm.StateMachine(“player");
This forms the root element within the state machine hierarchy that the rest of the model belongs to.
With this in place, we can add the top level states and pseudo states:
var initial = new fsm.PseudoState("initial", player,
                                  fsm.PseudoStateKind.Initial);
var operational = new fsm.State("operational", player);
var finalState = new fsm.FinalState("final", player);
The root state machine must have an initial pseudo state defined in order to support initialisation of the state machine instance objects (context). When adding the first child, state.js automatically injects a default region object under the player object and all subsequent child states are added to it.
We then add some more states as children of the operational state:
var deepHistory = new fsm.PseudoState("history", operational,                                       fsm.PseudoStateKind.Initial);
var stopped = new fsm.State("stopped", operational);
var active = new fsm.State("active", operational).entry(engageHead)                                                  .exit(disengageHead);
Again, a default region is created under the operational state, turning it into a composite state and the three children are added to it. The active state also has behaviour defined for state entry and exit, controlling the players head.
To complete the hierarchy, more states under the active state above:
var running = new fsm.State("running", active).entry(startMotor).exit(stopMotor);
var paused = new fsm.State("paused", active);
Note here we have not defined an initial pseudo state; this is because we will use an external transition later to transition to the running state directly, bypassing the need for it. The control of the players motor is performed by the pairing of the startMotor and stopMotor calls defined on the running state.
Next, we add the transitions from initial states:
initial.to(operational);
deepHistory.to(stopped);
Finally, we add the message triggered transitions that will respond to events; in this case, strings of text:
stopped.to(running).when(function (s) { return s === "play"; });
active.to(stopped).when(function (s) { return s === "stop"; });
running.to(paused).when(function (s) { return s === "pause"; });
paused.to(running).when(function (s) { return s === "play"; });
operational.to(finalState).when(function (s) { return s === "off"; });
The to method above creates transitions from source to target, and the when method defines the guard condition that must be met in order to traverse the transition. In this case, the guards only need the message passed to the machine in order to determine if the transitions should be traversed, therefore only a single parameter is used; a second parameter of the state machine context is also available if required.
The final JavaScript code therefore looks as follows:
var player = new fsm.StateMachine("player");
var initial = new fsm.PseudoState("initial", player,                                   fsm.PseudoStateKind.Initial);
var operational = new fsm.State("operational", player);
var finalState = new fsm.FinalState("final", player);
var deepHistory = new fsm.PseudoState("history", operational,                                       fsm.PseudoStateKind.Initial);
var stopped = new fsm.State("stopped", operational);
var active = new fsm.State("active", operational).entry(engageHead)                                                  .exit(disengageHead);
var running = new fsm.State("running", active).entry(startMotor).exit(stopMotor);
var paused = new fsm.State("paused", active);
initial.to(operational);
deepHistory.to(stopped);
stopped.to(running).when(function (s) { return s === "play"; });
active.to(stopped).when(function (s) { return s === "stop"; });
running.to(paused).when(function (s) { return s === "pause"; });
paused.to(running).when(function (s) { return s === "play"; });
operational.to(finalState).when(function (s) { return s === "off"; });
This example shows that, assuming we are in the running state, no matter what message caused a transition out, the controller will stop the motor and if the transition also causes the state machine instance to exit the active state, the head will also disengage.
TypeScript
This version of the code is equivalent to the final JavaScript above; bar a few layout issues and enum handling, it will compile into the same JavaScript code.
var player = new fsm.StateMachine("player");
var initial = new fsm.PseudoState("initial", player, fsm.PseudoStateKind.Initial);
var operational = new fsm.State("operational", player);
var finalState = new fsm.FinalState("final", player);
var deepHistory = new fsm.PseudoState("history", operational,                                       fsm.PseudoStateKind.Initial);
var stopped = new fsm.State("stopped", operational);
var active = new fsm.State("active", operational).entry(engageHead)                                                  .exit(disengageHead);
var running = new fsm.State("running", active).entry(startMotor).exit(stopMotor);
var paused = new fsm.State("paused", active);
initial.to(operational);
deepHistory.to(stopped);
stopped.to(running).when((s: string): boolean => { return s === "play"; });
active.to(stopped).when((s: string): boolean => { return s === "stop"; });
running.to(paused).when((s: string): boolean => { return s === "pause"; });
paused.to(running).when((s: string): boolean => { return s === "play"; });
operational.to(finalState).when((s: string): boolean => { return s === "off"; });
Debugging
The simplest way to debug your code is to add behaviour to states and transitions to log state entry, exit and transitions being performed by your state machines.
Further debugging tools will be available in a future release of state.js.
UML conformance
State.js conforms to the UML standard wherever possible, but in the following areas changes have been made:
No doActivity behaviour in states
The UML specification defines an additional type of behaviour for states called doActivity. This is executed after a state is entered and stops either naturally, or when the state is exited.
Having the doActivity executing and processing events requires some form of threading which is not required elsewhere in state.js
This can be worked-around by initiating any doActivity requirements in the state’s entry behaviour and terminating it if required in the states exit behaviour. In this way, the threading model is in the control of the user code.
Any state can be a final state
UML defines a subclass of state called FinalState that, when reached, denotes the enclosing region is deemed to be complete and cannot respond to messages passed to it. When all regions within a composite state are deemed to be complete, it is possible for a completion from the composite state to be traversed.
Within state.js, any state having no outbound transitions is deemed to be a final state and hence when reached, the enclosing region will be deemed complete. Essentially, FinalState is substitutable with a State.
No fork or join pseudo states
Fork pseudo states provide an alternate mechanism to enter and exit orthogonal states, without using initial states or final states. Forks perform external transitions to states or pseudo states in different regions under the same orthogonal states; joins do the reverse.
This is not implemented within state.js due to the complexity of tracking all incoming transitions to the join pseudo state before it can complete.
This can be worked around by simply using orthogonal states whose child regions have initial pseudo states and final states within. A completion transition from the orthogonal state will only be traversed when all child region are complete.
No connection point reference, entry point or exit point
To be honest, I’m yet to understand the value of these over entry to a composite state as a target of a transition or via an external transition.
No protocol state machines
All the classes in the UML superstructure specification in support of protocol state machines remains unimplemented to date. If there is demand, this should be feasible.
Acknowledgements
A big thank-you goes out to the following people who have all helped and contributed in many different ways: Yuriy Shaulko, Peter Moon, Nick Caine, Brice Morin, Tom Flemming.

    </section>
    </main>
<footer>
    <ul>
        <li><a href="/opensource/state.cs"state.cs</li>
        <li><a href="/opensource/state.js"state.js</li>
    </ul>
    <ul>
        <li><Cookies</li>
        <li>Privacy</li>
    </ul>
    <ul class="fa-ul">
      <li><i class="fa-li fa fa-flag"></i><a href="http://fortawesome.github.io/Font-Awesome/">Font Awesome</a></li>
      <li><i class="fa-li fa fa-github"></i><a href="https://pages.github.com">Github Pages</a></li>
      <li><i class="fa-li fa fa-google"></i><a href="http://www.google.com/fonts">Google Fonts</a></li>
      <li><i class="fa-li fa fa-yahoo"></i><a href="http://yuilibrary.com/yui/docs/cssnormalize/">YUI CSS Normalize</a></li>
    </ul>
</footer>
<div id="copyright">
    <p>&copy; 2015 Steelbreeze Limited, all rights reserved.</p>
</div>
<script>
document.write('<script src="//js.sharebutton.org/plugin/sharebutton.php?type=horizontal&u=' + encodeURIComponent(document.location.href) + '"></scr' + 'ipt>');
</script>
  </body>
</html>