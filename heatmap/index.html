<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Application portfolio</title>
	<link rel="stylesheet" href="./style.css" media="all">
</head>

<body>
	<header>
		<h2>Mythical bank</h2>
		<h1>Application portfolio heat-maps</h1>
	</header>
	<table class="heatmap">
		<tbody id="lineOfBusiness">
		</tbody>
	</table>
	<table class="timeline">
		<tbody>
			<tr>
				<td colspan="3">View as of: <span id="dateOfInterest"></span></td>
			</tr>
			<tr>
				<td colspan="3"><input type="range" min="-1095" max="1096" value="0" class="slider" id="myRange"
						oninput="showVal(this.value)" /></td>
			</tr>
			<tr>
				<td id="earliestDate">Earliest</td>
				<td id="todaysDate">Today</td>
				<td id="latestDate">Latest</td>
			</tr>
		</tbody>
	</table>
	<p>The heat map above is auto-generated from a <a href="./data/mythicalBank.json">JSON file</a> containing
		information about applications and the context in which they are used. Heat maps with merged and split cells
		convey a great deal of information in a compact form.</p>
	<p>The process from raw data to the table above is as follows:</p>
	<ol>
		<li>Extract the unique values for the x and y axis;</li>
		<li>Determine the optimal sequences of x and y axis values to position the same applications of the same status
			together;</li>
		<li>Produce a table using the optimal x and y axis where cells containing multiple applications are split and
			applications of the same status in neighbouring cells merged.</li>
	</ol>
	<p>These operations are performed in seperate calls to the library, therefore if you want a preset x and y axis, you
		can skip the first two steps alltogether, or substitute your own methods.</p>
	<h3>Browser support</h3>
	<p>The layout engine is writtin in TypeScript and transpiled into JavaScript ES3; it should therefore work in any
		browser. Apple Safari and Microsoft Edge both have table rendering issues where there are complex split cell
		scenarios; Google Chrome and Mozilla Firefox both work well.</p>
	<h3>Outstanding work</h3>
	<p>Add a function to help select a preferred scenario.</p>
	<p>Split cells with multiple application horizontally in addition to vertically if preferable.</p>
	<p>Smarter ordering of split cells to expliot affinity with neighbouring cells.</p>

	<script src="./dist/d3.min.js"></script>
	<script src="./dist/layout.min.js"></script>
	<script>
		// extract any URL parameters to define dimensions
		const urlParams = new URLSearchParams(window.location.search);
		const x = urlParams.get("x") || "product";
		const y = urlParams.get("y") || "capability";
		const today = new Date();
		let data = undefined;
		let scenario = undefined;

		// update the slider labels
		d3.select("#earliestDate").text(addDays(today, -1095).toLocaleDateString());
		d3.select("#todaysDate").text(today.toLocaleDateString());
		d3.select("#latestDate").text(addDays(today, 1096).toLocaleDateString());

		// load the applications data
		d3.json("./data/mythicalBank.json").then(function (json) {
			// update the returned data to make dates Date objects
			data = json.map(mapApp);

			// extract the axes from the application data
			const axes = layout.getAxes(data, x, y);

			// find the optimum layout scenarios
			const scenarios = layout.getOptimalAxes(data, axes/*, forceY*/); // NOTE: you can override the functions used to iterate a dimension

			// select the preferred scenario
			if (scenarios.length !== 0) {
				scenario = scenarios[0];

				showVal(0);
			}
		});

		function addDays(date, days) {
			var result = new Date(date);

			result.setMilliseconds(result.getMilliseconds() + (days * 1000 * 60 * 60 * 24));

			return result;
		}

		function showVal(val) {
			day = addDays(today, val);
			applications = filterByDate(data, day);

			table2 = layout.getTable(applications, scenario);

			d3.select("#dateOfInterest").text(day.toLocaleDateString());

			renderTable("#lineOfBusiness", table2);
		}

		// render a table with formatted data
		function renderTable(id, table) {
			// clear all rows from the table
			d3.select(id).selectAll("tr").remove();

			// create the new table
			d3.select(id)
				.selectAll("tr").data(table).enter().append("tr")
				.selectAll("td").data(function (row) { return row; }).enter().append("td")
				.text(function (cell) { return cell.name; })
				.attr("class", function (cell) { return `${cell.style} height${Math.round(cell.height / 10)}`; })
				.attr("colspan", function (cell) { return cell.colspan; })
				.attr("rowspan", function (cell) { return cell.rowspan; });
		}

		// alternative function to considering all permutations of the y axis; to pass into layout.getOptimalAxes
		function forceY() {
			return [["Market gateway", "Order execution", "Confirmations", "Settlement"]];
		}

		// map raw JSON data to format required in layout engine (transform date strings into dates)
		function mapApp(app) {
			return { name: app.name, uses: app.uses.map(mapUse) };
		}
		function mapUse(use) {
			const result = {
				product: use.product, capability: use.capability, location: use.location,
				commissioned: use.commissioned ? new Date(use.commissioned) : undefined,
				decommissioned: use.decommissioned ? new Date(use.decommissioned) : undefined,
				status: use.status
			};



			return result;
		}


		function between(date, start, end) {
			return (start === undefined || date >= start) && (end === undefined || date <= end);
		}

		function filterByDate(applications, date) {
			return applications.map(function (app) { return { name: app.name, uses: app.uses.filter(function (use) { return between(date, use.commissioned, use.decommissioned); }) } }).filter(function (app) { return app.uses.length > 0; });
		}
	</script>
</body>

</html>